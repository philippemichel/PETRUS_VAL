---
subtitle: "Qualification des intervenants --- V1.3c"
---

```{r}
#| label: setup

rm(list = ls())
#
library(baseph)
library(tidyverse)
library(gtsummary)
library(kableExtra)
library(lubridate)
library(readODS)
library(labelled)
library(epiDisplay)
library(visdat)
library(GGally)
library(irr)
library(colorspace)
library(apyramid)

#
theme_gtsummary_language(language = "fr", decimal.mark = ",")
options(OutDec = ",")
#
load("datas/validation.RData")
exp <- TRUE
classeur <- "validation1.ods"
# if (exp){system(paste0("rm -f ",classeur))}
#
cat <- list(all_continuous() ~ "wilcox.test", all_categorical() ~ "chisq.test")
affl <- list(all_categorical()~"{n}/{N} ({p})")
```




# Réponses


## Mesures réalisées

On regarde en premier le nombre de réponses (mesures réellement effectuées) par lecteur. La colonne `total` représente le nb de mesures que le lecteur aurait du faire. La colonne `vrai` les mesures réellement réalisées. 

```{r}
#| label: tbl-nb-rep
#| tbl-cap: Nombre de réponses


total <- tt |> 
  group_by(nom) |>
  summarise(
    total = n())

vrai <- tt |>
  dplyr::filter(!is.na(dif)) |>
  group_by(nom) |>
  summarise(
    vrai = n())

tta <- vrai
tta$total <- total$total

tta <- tta |> 
  mutate("% Réponses" = paste0(round(100*vrai/total, 0), " %"))

tta |> 
  kbl(booktabs = TRUE, longtable = T) |> 
  kable_styling(latex_options = c("striped", "hold_position"))


    if (exp) {
      tta |>
        as_tibble() |>
        write_ods(path = classeur, sheet = "nbreponses", append = TRUE)
    }

```
 
# Erreur

On compte le nombre de cas où la mesure du lecteur diffère de plus de \qty{1}{\mm} de la moyenne des mesures des experts. Ne sont prises en compte que les mesures effectuées pas les <*mesure impossible*> ou autre. 

```{r}
#| label: tbl-nbrerreur
#| tbl-cap: "Nombre d'erreurs de mesure par lecteur"

zz <- tt |> 
  mutate(erreur = ifelse(dif> 1,1,0)) |> 
  group_by(nom) |> 
  summarise('nb erreur' = sum(erreur,na.rm = TRUE)) |> 
  mutate(total = total$total) 

zz |> 
  kbl(booktabs = TRUE,  longtable = TRUE)|> 
  kable_styling(latex_options = c("striped", "hold_position"))

    if (exp) {
      zz |>
        as_tibble() |>
        write_ods(path = classeur, sheet = "nberreur", append = TRUE)
    }
```
\newpage

## Erreurs  par coupe

Pour ce tableau on considère que s'il y a une erreur sur les diamètres du nerf & de sa gaine sur la même coupe il s'agit de la même erreur.

```{r}
#| label: tbl-erreur-couple
#| tbl-cap: Erreurs couplées

nee = c(Lecteur = "nom", "Nombre d'erreurs "= "erreurt", 'Nombre coupes' = "n")

zz <- tt |> 
  mutate(erreur = ifelse(dif >1, 0,1)) |> 
  group_by(nom, coupe) |>
  summarise(erreurt = sum(erreur),
            n = n()) |> 
  mutate(erreurt = ifelse(erreurt == 2, 0,1)) |> 
  group_by(nom) |>
  summarise(erreurt = sum(erreurt, na.rm = TRUE),
            n = n()) |> 
rename(all_of(nee))             
                              
zz |> 
    kbl(booktabs = TRUE, longtable = TRUE)|> 
  kable_styling(latex_options = c("striped", "hold_position"))

    if (exp) {
      zz |>
        as_tibble() |>
        write_ods(path = classeur, sheet = "nberreurcouple", append = TRUE)
    }


```



# Concordance des diagnostics  

La concordance des diagnostics  est évaluée par un \gls{icc}  inter-évaluateurs (modèle à un facteurs à effets aléatoires — one-way random). Un \gls{icc} > 0,75 peut être considéré comme correct.

## Bland-Altman


```{r}
#| label: fig-blandaltman
#| fig-cap: Concordance des mesures entre lecteurs et experts (Bland-Altman)

ggplot(tt, aes(x = expert, y = lecteur-expert, color = type)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black") +
  geom_hline(yintercept = -1, linetype = "dashed", color = "black") +
  geom_hline(aes(yintercept = mean(lecteur - expert, na.rm = TRUE)), color = "blue") +
  labs(
    title = "Concordance des mesures entre lecteurs et experts",
    subtitle = "Diagramme de  Bland-Altman",
    x = "Mesures des Experts",
    y = "Différence des mesures (Lecteur - Expert)",
    caption = "Les lignes en pointillés représentent les limites de concordance à ± 1 mm,
    
    la ligne bleu la moyenne des différences."
  ) +
       theme_minimal() +
  scale_fill_discrete_qualitative(palette = "Dark 3") +
  theme(
    plot.title = element_text(size = 10, face = "bold"),
    plot.subtitle = element_text(size = 8),
    legend.title = element_blank(),
    axis.title.x = element_text(size = 8),
    axis.title.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    legend.position = "top"
  )                                                                                                                    
```


Les lecteurs ont tendance à surévaluer les tailles par rapport aux experts.

## ICC global

```{r}
#| label: icc-results

zz <- tt |> 
  dplyr::select(lecteur, expert) |>
  na.omit() |>
icc(
  model = "oneway", 
  type = "consistency", unit = "single"
  )

```

Le calcul est réalisé sur `r round(zz$subjects,2)` mesures. L'\gls{icc}  est de `r round(zz$value, 2)` (IC95% : `r round(zz$lbound, 2)` - `r round(zz$ubound, 2)`), ce qui indique une **`r ifelse(zz$value > 0.75, "bonne", "mauvaise")` concordance** entre les lecteurs et les experts.

\newpage

## ICC par lecteur

```{r}
#| label: tbl-icc
#| tbl-cap: ICC par lecteur

nn <- levels(tt$nom)

icc_lecteur <- function(nom_lect) {
  ttx <- tt |> 
 #   dplyr::filter(type == "nerf") |>
    dplyr::filter(nom == nom_lect) |>
    dplyr::select(lecteur, expert) |>
    na.omit()
  zz <- icc(
    ttx,
    model = "oneway", 
    type = "consistency", unit = "single"
  )
  return(c(nom_lect,nrow(ttx),paste0(round(zz$value, 2), " (", round(zz$lbound, 2), " - ", round(zz$ubound, 2), ")")))
}
  #
  zz <- NULL
  for(i in 1:length(nn)) {
    ll <- icc_lecteur(nn[i])
    zz <- rbind(zz, ll)
  }
  zz <- as_tibble(zz)
  names(zz) <- c("Lecteur", "Nb mesures", "ICC (IC95%)")
  #
  zz |> 
    kbl(booktabs = TRUE)|> 
  kable_styling(latex_options = c("striped", "hold_position"))

    if (exp) {
      zz |>
        as_tibble() |>
        write_ods(path = classeur, sheet = "icc", append = TRUE)
    }
  
```

```{r}
#| label: fig-icc
#| fig-cap: ICC par lecteur

icc_lecteur <- function(nom_lect) {
  ttx <- tt |> 
    dplyr::filter(nom == nom_lect) |>
    dplyr::select(lecteur, expert) |>
    drop_na()
  zz <- icc(
    ttx,
    model = "oneway", 
    type = "consistency", unit = "s"
  )
  return(list(nom = nom_lect, 
              icc = as.numeric(zz$value), 
              icb = as.numeric(zz$lbound), 
              ich = as.numeric(zz$ubound)))
}
  zz <- NULL
  for(i in 1:length(nn)) {
    ll <- icc_lecteur(nn[i])
    zz <- rbind(zz, c(ll$icc, ll$icb, ll$ich))
  }
  zz <- as_tibble(zz)
  zz$nom <- nn
  names(zz) <- c("ICC", "icb", "ich","Lecteur")

  zz |> 
    ggplot(aes(x = reorder(Lecteur, ICC), y = ICC)) +
    geom_point() +
    geom_errorbar(aes(ymin = icb, ymax = ich), width = 0.2) +
    geom_hline(yintercept = 0.75, linetype = "dashed", color = "red") +
    scale_y_continuous(limits = c(0.4, 1), breaks = seq(0.4, 1, by = 0.2)) +
    coord_flip() +
    labs(
      title = "ICC par lecteur",
      x = "Lecteur",
      y = "ICC (avec IC95%)",
      caption = "La ligne en pointillés rouges représente le seuil de 0,75 (bonne concordance)."
    ) +
      theme_minimal() +
  scale_fill_discrete_qualitative(palette = "Dark 3") +
  theme(
    plot.title = element_text(size = 10, face = "bold"),
    plot.subtitle = element_text(size = 8),
    axis.title.x = element_text(size = 8),
    axis.title.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    legend.position = "none"
  )
```

# Versions

## V1.3 (29/01/26)

- Analyse des erreurs couplées
- Nouvelles lectures des experts pour deux investigateurs
